JS的语法借鉴自Java, 函数借鉴自Scheme, 原型继承借鉴自Self, 而其正则就正是借鉴自Perl.

可以使用正则的方法十分固定

* `regexp.exec()`
* `regexp.test()`
* `string.match()`
* `string.replace()`
* `string.search()`
* `string.split()`

要理解正则十分困难, 因为其中相同的字符作为字面量还是运算符仅仅取决于位置, 其书写规则十分复杂. 而且正则趋向于极致的简洁, 为此就必须牺牲其语言的精确度.
JS的正则十分难以阅读, 因为不支持空白和注释. 阅读和理解你所使用的自行编写的正则表达式对代码能否正常工作十分重要.

### An Example

```js
var parse_url = /^(?:([A-Za-z]+):)?(\/{0,3})([0-9.\-A-Za-z]+)(?::(\d+))?(?:\/([^?#]*))?(?:\?([^#]*))?(?:#(.*))?$/;

var result = parse_url.exec('http://www.baidu.com:8081/goodpart?q#fragment');

var names = ['url', 'scheme', 'slash', 'host', 'port', 'path', 'query', 'hash'];

var blanks = '    ';

var i;

for (i = 0; i < names.length; i++) {
    console.log(names[i] + ':' + blanks.substring(names[i].length) + result[i]);
}
```

* `^` 表示这个字符串的开始, 它是一个锚, 指引exec只匹配从一开始就像URL的字符串.

* `(?:([A-Za-z]+):)?`
  
  这个因子用来匹配协议名, 并输出协议名称的字母部分到`result[1]`, 但仅当它后面跟一个冒号时才匹配.
  
  + `(?:....)?` 表示是一个非捕获性分组, 后置的`?`表示这个分组是可选的, 也就是会被匹配0或者1次.
  
  + `(?:(...))` 表示内部小括号内是一个捕获型分组(第一个捕获型分组所匹配的文本会被放置在`result[1]`中)
  
  + `(?:([...]+))` 中括号表示一个字符类, `A-Za-z`这个字符类包含26*2个大小写字母, `-`表示范围, `+`表示这个字符类会被匹配至少一次, 而`:`这个字符属于外层的非捕获组, 并且按照字面进行匹配.

* `(\/{0,3})` 这是捕获型分组2, `\/`其中`\`负责转义, 表示会匹配`/`, 而后缀`{0,3}`则表示会被匹配0~3次.

* `([0-9.\-A-Za-z]+)` 捕获型分组3, 其中的字符类会匹配一个或者多个数字或者字母或者`.`或者`_`. 其中下划线经过转义.

* `(?::(\d+))?` 首先非捕获组`:(\d+)`中包含了捕获组`\d+`表示连续的数字, 而末尾的`?`同样表示可选

* `(?:\/([^?#]*))?` 非捕获组`\/([^?#]*)`, 以`/`开头, `[^#?]*`其中字符类表示除了`#`和`?`之外的所有字符, `*`表示会被匹配0次或者多次.

* 剩下的两个部分`(?:\?([^#]*))?`和`(?:#(.*))?`会匹配`?`和`#`之后的部分, 同时`.`表示任意字符, 而`#`不需要转义

* `$` 表示字符串的结尾.

JS中最没有移植性的部分就是正则, 结构复杂或者令人费解的正则会导致移植性问题, 而且嵌套的正则可能会导致非常恶劣的性能问题. 所以JS中正则应该尽量简单.

### Another Example

```js
var parse_number = /^-?\d+(?:\.\d*)?(?:e[+\-]?\d+)?$/i
```

### Construction

正则可以使用字面量进行创建 也可以使用构造函数, 但是为了方便直观, 一般使用前者.

同时正则有一些flag, i/g/m(multiple)

### Regexp Elements

* Choice: '|' 表示或

* Sequence: 序列包含一个或者多个正则表达式因子, 每个因子能选择是否跟随一个量词, 如果没有量词则只匹配一次.

* Factor: 一个正则表达式因子可以是一个字符, 一个由圆括号包围的组, 一个字符类, 或者一个转义序列. 除了控制字符和特殊字符以外, 所有的字符都会按照字面处理.
  
  * `'\'` 
  * `'/'`
  * `'[]'`
  * `'()'`
  * `'{}'`
  * `'?'`
  * `'+'`
  * `'*'`
  * `'|'`
  * `'.'`
  * `'^'`
  * `'$'`
以上字符用来匹配需要进行转义

* Escape
  
  * `\n` 换行 `\f` 换页 `\r` 回车 `\t` 制表 `\u` Unicode
  * `\d` 等同于`[0-9]`, 而`\D`表示其反
  * `\s` 表示unicode空白, 而`\S`表示其反
  * `\w` 等同于`[0-9A-Za-z]`, 而`\W`表示其反
  * `\b` 字边界, 比较遗憾的是用`\w`去寻找字边界, 对于大多数语言其实无用
  * `\num` 表示第num个分组匹配结果.

* Group
  
  + `(....)` 捕获型
  + `(?:....)` 非捕获型
  + `(?=....)` 向前正匹配
  + `(?!....)` 向前负匹配

  后两种匹配不是很好的语言特性

* Class
  ```js
  var some = '!"#$%&\'()*+,-./:;<=>?@[\]^_`{|}~'

  var regexp = /[!-\/:-@\[-`{-~]/;
  ```
* Class Escape
  
  在字符类中, 一下字符需要被转义
  
  * `-`
  * `/`
  * `[` `]`
  * `\\`
  * `^`

* Quantifier
  
  * `{min, max}`
  * `?` = `{0,1}`
  * `*` = `{0,}`
  * `+` = `{1,}`
  
  如果只有一个量词, 则趋向于进行贪婪匹配, 尽可能达到上限, 如果两次后缀加一个`?`, 则是非贪婪匹配, 只需要匹配必要的副本.

  
  
  
